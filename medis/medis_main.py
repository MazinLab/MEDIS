"""
run_medis_main
Kristina Davis, Rupert Dodkins

This is the version of code compiled by K. Davis and R. Dodkins updated and streamlined from the MEDISv0.0 version of
the code written by R. Dodkins for his graduate career. This code contains the same functionality as MEDISv0.0 and is
modular to continue adding features and functionality.

MEDIS is split into two main functionalities; the first is to do an end-to-end simulation of a telescope. This is more
or less a large wrapper for proper with some new capabilities built into it to enable faster system design.The second
main functionality is to convert the complex field data generated by the telescope simulator to MKID-type photon lists.

For the telescope simulator, the user builds a prescription "name.py" of the optical system of the telescope system as
a separate module in the Simulations subdirectory of MEDIS. They can then update the default params file in a "
run_name.py" type script, which also makes the call to run_medis to start the simulation. The output is a 6D complex
field observation sequence.

Rupert will fill in the overview of the MKIDS part.

"""
import os
import sys
import numpy as np
import multiprocessing
import time
import traceback
import glob
import pickle
import shutil
from datetime import datetime
import h5py

# from medis.params import iop, ap, tp, sp, cdip, mp
# from medis.params import params
import proper
import medis.atmosphere as atmos
from medis.plot_tools import view_spectra
import medis.CDI as cdi
import medis.utils as mu
import medis.MKIDs as MKIDs
import medis.optics as opx
import medis.aberrations as aber
from medis.controller import auto_load
from medis.light import Fields

################################################################################################################
################################################################################################################
################################################################################################################
sentinel = None


class RunMedis():
    """
    Creates a simulation for calling Telescope or MKIDs to return a seriess of complex electric fields or photons,
    respectively.

    Upon creation the code checks if a testdir of this name already exists, if it does it then checks if the params
    match. If the params are identifcal and the desired products are not already created, if it will create them.
    If the params are different or the testdir does not already exist a new testdir and simulation is created

    File structure:
    datadir
        testdir
            params.pkl
    """
    def __init__(self, params, name='test', product='fields'):
        """

        :param params:
        :param name:
        :param product:
        """

        self.params = params
        self.name = name
        self.product = product

        self.params['iop'].update(self.name)

        if self.params['sp'].debug:
            for param in [self.params['iop']]:
                pprint(param.__dict__)

        # always make the top level directory if it doesn't exist yet
        if not os.path.isdir(self.params['iop'].datadir):
            print(f"Top level directory... \n\n\t{self.params['iop'].datadir} \n\ndoes not exist yet. Creating")
            os.makedirs(self.params['iop'].datadir, exist_ok=True)

        if not os.path.exists(self.params['iop'].testdir):
            print(f"No simulation data found at... \n\n\t{self.params['iop'].testdir} \n\n A new test simulation"
                  f" will be started")
            self.make_testdir()
        else:
            params_match = self.check_params()
            exact_match = all(params_match.values())
            if exact_match:
                print(f"Configuration files match. Initialization over")
            else:
                print(f"Configuration files differ. Creating a new test directory")
                now = datetime.now().strftime("%m:%d:%Y_%H-%M-%S")
                self.params['iop'].update(self.name+'_newsim_'+now)
                self.make_testdir()

    def make_testdir(self):
        if not os.path.isdir(self.params['iop'].testdir):
            os.makedirs(self.params['iop'].testdir, exist_ok=True)

        with open(self.params['iop'].params_logs, 'wb') as handle:
            pickle.dump(self.params, handle, protocol=pickle.HIGHEST_PROTOCOL)

    def check_params(self):
        """ Check all param classes apart from mp since that is not relevant at this stage """

        with open(self.params['iop'].params_logs, 'rb') as handle:
            loaded_params = pickle.load(handle)

        match_params = {}
        for p in ['ap','tp','atmp','cdip','iop','sp']:  # vars(self.params).keys()
            matches = []
            for (this_attr, this_val), (load_attr, load_val) in zip(self.params[p].__dict__.items(),
                                                                    self.params[p].__dict__.items()):
                matches.append(this_attr == load_attr and np.all(load_val == this_val))

            match = np.all(matches)
            print(f"param: {p}, match: {match}")
            match_params[p] = match

        return match_params

        # return {'ap':False, 'tp':True, 'atmp':True, 'cdip':True, 'iop':True, 'sp':True}

    def __call__(self, *args, **kwargs):
        if self.product == 'fields':
            telescope_sim = Telescope(self.params)
            output = telescope_sim()
            # output = self.telescope()
        elif self.product == 'photons':
            camera_sim = Camera(self.params)
            output = camera_sim()
            # output = self.MKIDs()

        return output

    def MKIDs(self):
        """
        Todo this needs to be migrated to its own class

        :return:
        """
        # initialize MKIDs
        MKIDs.initialize()

        with open(self.params['iop'].device, 'rb') as handle:
            dp = pickle.load(handle)

        cpx_sequence, sampling = self.telescope()

        photons = np.empty((0, 4))
        stackcube = np.zeros((len(cpx_sequence), self.params['ap'].n_wvl_final, mp.array_size[1], mp.array_size[0]))
        for step in range(len(cpx_sequence)):
            print('step', step)
            spectralcube = np.abs(np.sum(cpx_sequence[step, -1, :, :], axis=1)) ** 2
            # view_spectra(spectralcube, logZ=True)
            step_packets = MKIDs.get_packets(spectralcube, step, dp, mp)
            photons = np.vstack((photons, step_packets))
            cube = MKIDs.make_datacube_from_list(step_packets, (self.params['ap'].n_wvl_final, dp.array_size[0], dp.array_size[1]))
            stackcube[step] = cube

        # with open(self.params['iop'].form_photons, 'wb') as handle:
        #     pickle.dump((photons, stackcube), handle, protocol=pickle.HIGHEST_PROTOCOL)

        return {'photons': photons, 'stackcube': stackcube, 'sampling': sampling}

class Telescope():
    """
    Creates a simulation for the telescope to create a series of complex electric fields

    During initialisation a backup of the pthon PROPER prescription is copied to the testdir, atmisphere maps and
    aberration maps are created, serialisation and memory requirements are tested, and the cdi vairable initialised

    File structure:
    datadir
        testdir
            params.pkl
            telescope
                {prescriptionname}
                    {prescriptionname}.py
            aberrations
                {aberationparams}
                    {lensname}0.fits
                    ...
            atmosphere
                {atmosphereparams}
                    {atmos}0.fits
                    ...
            fields.h5

    input
    params dict
        collection of the objects in params.py

    :return:
    self.cpx_sequence ndarray
        complex tensor of dimensions (n_timesteps, n_saved_planes, n_wavelengths, n_stars/planets, grid_size, grid_size)
    """

    def __init__(self, params):
        # if not initialise atmosphere
        # aberrations etc

        self.params = params

        self.save_exists = True if os.path.exists(self.params['iop'].fields) else False

        if not self.save_exists:
            # copy over the prescription
            self.params['iop'].prescopydir = self.params['iop'].prescopydir.format(self.params['tp'].prescription)
            self.target = os.path.join(self.params['iop'].prescopydir, self.params['tp'].prescription+'.py')
            if os.path.exists(self.target):
                print(f"Prescription already exists at \n\n\t{self.target} \n\n... skipping copying\n\n")
            else:
                prescriptions = self.params['iop'].prescriptions_root
                fullprescription = glob.glob(os.path.join(prescriptions, '**', self.params['tp'].prescription+'.py'),
                                             recursive=True)
                if len(fullprescription) == 0:
                    raise FileNotFoundError
                elif len(fullprescription) > 1:
                    print(f'Multiple precriptions at {fullprescription}')
                    raise FileExistsError

                fullprescription = fullprescription[0]
                print(f"Copying over prescription {fullprescription}")

                if not os.path.isdir(self.params['iop'].prescopydir):
                    os.makedirs(self.params['iop'].prescopydir, exist_ok=True)
                shutil.copyfile(fullprescription, self.target)
                sys.path.insert(0, os.path.dirname(self.target))

            # initialize atmosphere
            self.params['iop'].atmosdir = self.params['iop'].atmosdir.format(params['sp'].grid_size,
                                                                             params['sp'].beam_ratio,
                                                                             params['sp'].numframes)
            if glob.glob(self.params['iop'].atmosdir+'/*.fits'):
                print(f"Atmosphere maps already exist at \n\n\t{self.params['iop'].atmosdir}"
                      f" \n\n... skipping generation\n\n")
            else:
                if not os.path.isdir(self.params['iop'].atmosdir):
                    os.makedirs(self.params['iop'].atmosdir, exist_ok=True)
                atmos.gen_atmos()

            # initialize aberrations
            self.params['iop'].aberdir = self.params['iop'].aberdir.format(params['sp'].grid_size,
                                                                             params['sp'].beam_ratio,
                                                                             params['sp'].numframes)
            if glob.glob(self.params['iop'].aberdir + '/*.fits'):
                print(f"Aberration maps already exist at \n\n\t{self.params['iop'].aberdir} "
                      f"\n\n... skipping generation\n\n")
            else:
                if not os.path.isdir(self.params['iop'].aberdir):
                    os.makedirs(self.params['iop'].aberdir, exist_ok=True)
                for lens in params['tp'].lens_params:
                    aber.generate_maps(lens['aber_vals'], lens['diam'], lens['name'])

            # check if can do parrallel
            if params['sp'].closed_loop or params['sp'].ao_delay:
                print(f"closed loop or ao delay means sim can't be parrallelized in time domain. Forcing serial mode")
                params['sp'].parrallel = False

            # determine if can/should do all in memory
            max_steps = self.max_chunk()
            checkpoint_steps = max_steps if self.params['sp'].checkpointing is None else self.params['sp'].checkpointing
            self.chunk_steps = int(min([max_steps, self.params['sp'].numframes, checkpoint_steps]))
            if self.params['sp'].verbose: print(f'Using time chunks of size {self.chunk_steps}')
            self.num_chunks = self.params['sp'].numframes / self.chunk_steps

            if self.num_chunks > 1:
                print('Simulated data too large for dynamic memory. Storing to disk as the sim runs')
                self.params['sp'].chunking = True

            #todo remove the hard coding
            self.params['sp'].chunking = True
            self.params['sp'].parrallel = False
            self.params['sp'].ao_delay = False
            self.params['sp'].closed_loop = False

            self.markov = self.params['sp'].chunking or self.params['sp'].parrallel  # independent timesteps
            assert np.logical_xor(self.markov, self.params['sp'].ao_delay or self.params['sp'].closed_loop),\
                "Confliciting modes. Request requires the timesteps be both dependent and independent"

            modes = [self.params['sp'].chunking, self.params['sp'].ao_delay, self.params['sp'].parrallel,
                     self.params['sp'].closed_loop]

            # assert sum(np.int_(modes)) <= 1
            # self.mode = ['chunking',  'ao_delay', 'parrallel', 'closed_loop'][modes==True]

            # ensure contrast is set properly
            if self.params['ap'].companion is False:
                self.params['ap'].contrast = []

            # Initialize CDI probes
            if self.params['cdip'].use_cdi is True:
                self.theta_series = cdi.gen_CDI_phase_stream()
            else:
                self.theta_series = np.zeros(self.params['sp'].numframes) * np.nan  # string of Nans

    def __call__(self, *args, **kwargs):
        if self.save_exists:
            output = self.load_fields()
        else:
            output = self.create_fields()
        return output

    def max_chunk(self):
        """
        Determines the maximum duration each chunk can be to fit within the memory limit

        :return: integer
        """
        timestep_size = len(self.params['sp'].save_list) * self.params['ap'].n_wvl_final * \
                        (1 + len(self.params['ap'].contrast)) * self.params['sp'].grid_size**2 * 32

        max_chunk = self.params['sp'].memory_limit // timestep_size
        print(f'Each timestep is predicted to be {timestep_size/1.e6} MB, requiring sim to be split into '
              f'{max_chunk} time chunks')

        return max_chunk

    def create_fields(self, mode='chunking'):
        print('Beginning Telescope Simulation with MEDIS')
        print('***************************************')
        start = time.time()

        t0 = self.params['sp'].startframe
        self.kwargs = {'params': self.params, 'theta_series': self.theta_series}
        self.cpx_sequence = None

        if self.markov:  # time steps are independent
            for ichunk in range(int(np.ceil(self.num_chunks))):
                cpx_sequence = np.empty((self.chunk_steps, len(self.params['sp'].save_list),
                                        self.params['ap'].n_wvl_init, 1 + len(self.params['ap'].contrast),
                                        self.params['sp'].grid_size, self.params['sp'].grid_size),
                                        dtype=np.complex64)
                chunk_range = ichunk * self.chunk_steps + t0 + np.arange(self.chunk_steps)
                if self.params['sp'].num_processes == 1:
                    seq_samp_list = [self.run_timestep(t) for t in chunk_range]
                else:
                    pool = multiprocessing.Pool(processes=self.params['sp'].num_processes)
                    seq_samp_list = [pool.apply(self.run_timestep, args=(t,)) for t in chunk_range]
                self.cpx_sequence = [tup[0] for tup in seq_samp_list]
                self.sampling = seq_samp_list[0][1]

                if self.params['ap'].n_wvl_init < self.params['ap'].n_wvl_final:
                    self.cpx_sequence = opx.interp_wavelength(self.cpx_sequence, ax=2)
                    self.sampling = opx.interp_sampling(self.sampling)

                if self.params['sp'].save_to_disk: self.save(self.cpx_sequence)

        else:
            print('*** This is untested ***')
            self.cpx_sequence = np.zeros((self.params['sp'].numframes, len(self.params['sp'].save_list),
                                          self.params['ap'].n_wvl_init, 1 + len(self.params['ap'].contrast),
                                          self.params['sp'].grid_size, self.params['sp'].grid_size), dtype=np.complex)
            self.sampling = np.zeros((len(self.params['sp'].save_list), self.params['ap'].n_wvl_init))

            for it, t in enumerate(range(t0, self.params['sp'].numframes + t0)):
                WFS_ind = ['wfs' in plane for plane in self.params['sp'].save_list]
                if t > self.params['sp'].ao_delay:
                    self.kwargs['WFS_field'] = self.cpx_sequence[it - self.params['sp'].ao_delay, WFS_ind, :, 0]
                    self.kwargs['AO_field'] =  self.cpx_sequence[it - self.params['sp'].ao_delay, AO_ind, :, 0]
                else:
                    self.kwargs['WFS_field'] = np.zeros((self.params['ap'].n_wvl_init, self.params['sp'].grid_size,
                                                    self.params['sp'].grid_size), dtype=np.complex)
                    self.kwargs['AO_field'] = np.zeros((self.params['ap'].n_wvl_init, self.params['sp'].grid_size,
                                                        self.params['sp'].grid_size), dtype=np.complex)
                self.cpx_sequence[it], sampling = self.run_timestep(t)

            print('************************')
            if self.params['sp'].save_to_disk: self.save(self.cpx_sequence)

        print('MEDIS Telescope Run Completed\n**************************************')
        finish = time.time()
        print(f'Time elapsed: {(finish - start) / 60:.2f} minutes')

        self.pretty_sequence_shape()

        return {'fields': np.array(self.cpx_sequence), 'sampling': self.sampling}

    def run_timestep(self, t):
        self.kwargs['iter'] = t
        return proper.prop_run(self.params['tp'].prescription, 1, self.params['sp'].grid_size, PASSVALUE=self.kwargs)

    def pretty_sequence_shape(self):

        """
        displays data format easier

        :param cpx_sequence: the 6D complex sequence generated by run_medis.telescope
        :return: nicely parsed string of 6D shape--human readable output
        """
        samps = ['timesteps', 'save planes', 'wavelengths', 'num obj', 'x', 'y']
        delim = ', '
        print(f"Shape of cpx_sequence = " \
            f"{delim.join([samp + ':' + str(length) for samp, length in zip(samps, np.shape(self.cpx_sequence))])}")

    def save(self, fields):
        with h5py.File(self.params['iop'].fields, mode='a') as hdf:
            print(f"Saving observation data at {self.params['iop'].fields}")
            dims = np.shape(fields)
            keys = list(hdf.keys())
            print('dims', dims, keys)
            if 'data' not in keys:
                dset = hdf.create_dataset('data', dims, maxshape=(None,) + dims[1:],
                                          dtype=np.complex64, chunks=dims, compression="gzip")
                dset[:] = fields
            else:
                hdf['data'].resize((hdf["data"].shape[0] + len(fields)), axis = 0)
                hdf["data"][-len(fields):] = fields

    def load_fields(self):
        with h5py.File(self.params['iop'].fields, 'r') as hdf:
            keys = list(hdf.keys())
            if 'data' in keys:
                self.cpx_sequence = hdf.get('data')[:]
        self.pretty_sequence_shape()

        return {'fields': self.cpx_sequence, 'sampling': None}


if __name__ == '__main__':
    from medis.params import params

    sim = RunMedis(params=params, name='example1', product='fields')
    observation = sim()
    cpx_sequence = observation['fields']
    sampling = observation['sampling']

