"""
atmosphere.py

For mini-medis, code copied over from atmos.py and aberrations.py from Rupert's original MEDIS

Contains functions that will create, load, save, and apply atmospheric maps
"""
import numpy as np
import os
import astropy.io.fits as fits
import hcipy
import proper
from skimage.restoration import unwrap_phase

from medis.params import iop, ap, tp, sp, atmp
from medis.utils import dprint, clipped_zoom
import medis.optics as opx


def gen_atmos(params, plot=False):
    """
    generates atmospheric phase distortions using hcipy (updated from original using CAOS)

    read more on HCIpy here: https://hcipy.readthedocs.io/en/latest/index.html
    In hcipy, the atmosphere evolves as a function of time, specified by the user. User can thus specify the
    timescale of evolution through both velocity of layer and time per step in the obs_sequence, in loop for
    medis_main.gen_timeseries().

    :param plot: turn plotting on or off
    :return:
    """
    dprint("Making New Atmosphere Model")
    # Saving Parameters
    # np.savetxt(iop.atmosconfig, ['Grid Size', 'Wvl Range', 'Number of Frames', 'Layer Strength', 'Outer Scale', 'Velocity', 'Scale Height', cp.model])
    # np.savetxt(iop.atmosconfig, ['ap.grid_size', 'ap.wvl_range', 'ap.numframes', 'atmp.cn_sq', 'atmp.L0', 'atmp.vel', 'atmp.h', 'cp.model'])
    # np.savetxt(iop.atmosconfig, [ap.grid_size, ap.wvl_range, ap.numframes, atmp.cn_sq, atmp.L0, atmp.vel, atmp.h, cp.model], fmt='%s')

    wsamples = np.linspace(params['ap'].wvl_range[0], params['ap'].wvl_range[1], params['ap'].n_wvl_init)
    wavefronts = []

    ##################################
    # Initiate HCIpy Atmosphere Type
    ##################################
    pupil_grid = hcipy.make_pupil_grid(params['sp'].grid_size, params['tp'].entrance_d)
    if params['atmp'].model == 'single':
        layers = [hcipy.InfiniteAtmosphericLayer(pupil_grid, params['atmp'].cn_sq, params['atmp'].L0,
                                                 params['atmp'].vel, params['atmp'].h, 2)]
    elif params['atmp'].model == 'hcipy_standard':
        # Make multi-layer atmosphere
        layers = hcipy.make_standard_atmospheric_layers(pupil_grid, params['atmp'].outer_scale)
    elif params['atmp'].model == 'evolving':
        raise NotImplementedError
    atmos = hcipy.MultiLayerAtmosphere(layers, scintilation=False)

    for wavelength in wsamples:
        wavefronts.append(hcipy.Wavefront(hcipy.Field(np.ones(pupil_grid.size), pupil_grid), wavelength))

    ###########################################
    # Evolving Wavefront using HCIpy tools
    ###########################################
    for it, t in enumerate(np.arange(0, params['sp'].numframes*params['sp'].sample_time, params['sp'].sample_time)):
        atmos.evolve_until(t)
        for iw, wf in enumerate(wavefronts):
            wf2 = atmos.forward(wf)

            filename = get_filename(it, wsamples[iw], (params['iop'].atmosdir, params['sp'].sample_time,
                                    params['atmp'].model))
            dprint(f"atmos file = {filename}")
            hdu = fits.ImageHDU(wf2.phase.reshape(params['sp'].grid_size, params['sp'].grid_size))
            hdu.header['PIXSIZE'] = params['tp'].entrance_d/params['sp'].grid_size
            hdu.writeto(filename, overwrite=True)

            if plot and iw == 0:
                import matplotlib.pyplot as plt
                from medis.twilight_colormaps import sunlight
                plt.figure()
                plt.title(f"Atmosphere Phase Map t={t} lambda={eformat(wsamples[iw], 3, 2)}")
                hcipy.imshow_field(wf2.phase, cmap=sunlight)
                plt.colorbar()
                plt.show(block=True)


def add_atmos(wf, it, param_tup=None, spatial_zoom=False):
    """
    creates a phase offset matrix for each wavelength at each time step,
    sampled from the atmosphere generated by hcipy

    HCIpy generates an atmosphere with given parameters. The returned field is in units of phase delay for each
    wavelength. prop_add_phase wants the phase delay to be in units of meters for each wavelength, so we convert to
    meters via the wavelength/np.pi

    :param wf: a single (2D) wfo.wf_collection[iw,ib] at one wavelength and object
    :param it: timestep# in obs_sequence. Comes from medis_main.gen_timeseries()
    :return: nothing returned, wfo is modified with proper.prop_add_phase
    """
    if tp.use_atmos is False:
        pass  # don't do anything. Putting this type of check here allows universal toggling on/off rather than
                # commenting/uncommenting in the proper perscription
    else:
        wavelength = wf.lamda  # the .lamda comes from proper, not from Wavefronts class

        # Check for Existing File)
        atmos_map = get_filename(it, wavelength, param_tup)
        if sp.verbose: dprint(f"Atmos map applied is {atmos_map}")
        if not os.path.exists(atmos_map):
            # todo remove when all test scripts use the new format
            print('atmospheres should be created at the beginng, not on the fly')
            raise NotImplementedError
            gen_atmos(params, plot=True)

        atm_map = fits.open(atmos_map)[1].data
        atm_map = unwrap_phase(atm_map)
        atm_map *= wavelength/(2*np.pi)  # converts atmosphere in units of phase delay (rad) into distance (m)
        if spatial_zoom:
            scale = ap.wvl_range[0] / wavelength
            atm_map = clipped_zoom(atm_map, scale)
        proper.prop_add_phase(wf, atm_map)


def rotate_atmos(wf, it):
    time = it * ap.sample_time
    rotate_angle = tp.rot_rate * time
    wf.wfarr = proper.prop_shift_center(wf.wfarr)
    wf.wfarr = proper.prop_rotate(wf.wfarr, rotate_angle)
    wf.wfarr = proper.prop_shift_center(wf.wfarr)


def eformat(wvl, prec, exp_digits):
    """
    reformats wavelength into scientific notation in meters

    :param wvl: wavelength float
    :param prec: precision
    :param exp_digits: number of digits in the exponent
    :return:
    """
    s = "%.*e" % (prec, wvl)
    mantissa, exp = s.split('e')
    # add 1 to digits as 1 is taken by sign +/-
    return "%se%+0*d" % (mantissa, exp_digits + 1, int(exp))


def get_filename(it, lamda, param_tup=None):
    """
    returns the atmosphere map names in the format location/atmos_t<time>_<model>_wvl<wavelength>
    example output:

    :param it: time index
    :param lamda: wavelength, comes from metadata in proper wavefront object (ie wfo.wf_collection.lamda)
    :return:
    """
    wave = eformat(lamda, 3, 2)
    if param_tup:
        atmosdir, sample_time, model = param_tup
    else:
        atmosdir, sample_time, model = iop.atmosdir, sp.sample_time, atmp.model

    return f'{atmosdir}/atmos_t{sample_time*it:.3f}_{model}_wvl{wave}.fits'

