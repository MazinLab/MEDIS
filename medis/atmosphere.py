"""
atmosphere.py

For mini-medis, code copied over from atmos.py and aberrations.py from Rupert's original MEDIS

Contains functions that will create, load, save, and apply atmospheric maps
"""
import numpy as np
import os
import astropy.io.fits as fits
import hcipy
import proper
from skimage.restoration import unwrap_phase

from medis.params import iop, ap, tp, sp, atmp
from medis.utils import dprint
import medis.optics as opx

class Atmosphere():
    """
    Class responsible for getting atmosphere phase maps

    """
    def __init__(self):
        self.use_cache = True
        self.debug = True

    def can_load(self):
        if self.use_cache:
            file_exists = os.path.exists(iop.fields)
            if file_exists:
                configs_match = self.configs_match()
                if configs_match:
                    return True

        return False

    def configs_match(self):
        cur_config = self.__dict__
        cache_config = self.load_config()
        configs_match = cur_config == cache_config

        return configs_match

    def load_config(self):
        """ Reads the relevant config data from the saved file """
        pass

    def generate(self):
        pass

    def save(self):
        pass

    def load(self):
        pass

    def view(self):
        pass

def gen_atmos(plot=False):
    """
    generates atmospheric phase distortions using hcipy (updated from original using CAOS)

    read more on HCIpy here: https://hcipy.readthedocs.io/en/latest/index.html
    In hcipy, the atmosphere evolves as a function of time, specified by the user. User can thus specify the
    timescale of evolution through both velocity of layer and time per step in the obs_sequence, in loop for
    medis_main.gen_timeseries().

    :param plot: turn plotting on or off
    :return:
    """
    dprint("Making New Atmosphere Model")
    # Saving Parameters
    # np.savetxt(iop.atmosconfig, ['Grid Size', 'Wvl Range', 'Number of Frames', 'Layer Strength', 'Outer Scale', 'Velocity', 'Scale Height', cp.model])
    # np.savetxt(iop.atmosconfig, ['ap.grid_size', 'ap.wvl_range', 'ap.numframes', 'atmp.cn_sq', 'atmp.L0', 'atmp.vel', 'atmp.h', 'cp.model'])
    # np.savetxt(iop.atmosconfig, [ap.grid_size, ap.wvl_range, ap.numframes, atmp.cn_sq, atmp.L0, atmp.vel, atmp.h, cp.model], fmt='%s')

    wsamples = np.linspace(ap.wvl_range[0], ap.wvl_range[1], ap.n_wvl_init)
    wavefronts = []

    ##################################
    # Initiate HCIpy Atmosphere Type
    ##################################
    pupil_grid = hcipy.make_pupil_grid(sp.grid_size, tp.entrance_d)
    if atmp.model == 'single':
        layers = [hcipy.InfiniteAtmosphericLayer(pupil_grid, atmp.cn_sq, atmp.L0, atmp.vel, atmp.h, 2)]
    elif atmp.model == 'hcipy_standard':
        # Make multi-layer atmosphere
        layers = hcipy.make_standard_atmospheric_layers(pupil_grid, atmp.outer_scale)
    elif atmp.model == 'evolving':
        raise NotImplementedError
    atmos = hcipy.MultiLayerAtmosphere(layers, scintilation=False)

    for wavelength in wsamples:
        wavefronts.append(hcipy.Wavefront(hcipy.Field(np.ones(pupil_grid.size), pupil_grid), wavelength))

    ###########################################
    # Evolving Wavefront using HCIpy tools
    ###########################################
    for it, t in enumerate(np.arange(0, sp.numframes*sp.sample_time, sp.sample_time)):
        atmos.evolve_until(t)
        for iw, wf in enumerate(wavefronts):
            wf2 = atmos.forward(wf)

            filename = get_filename(it, wsamples[iw])
            dprint(f"atmos file = {filename}")
            hdu = fits.ImageHDU(wf2.phase.reshape(sp.grid_size, sp.grid_size))
            hdu.header['PIXSIZE'] = tp.entrance_d/sp.grid_size
            hdu.writeto(filename, overwrite=True)

            if plot and iw == 0:
                import matplotlib.pyplot as plt
                from medis.twilight_colormaps import sunlight
                plt.figure()
                plt.title(f"Atmosphere Phase Map t={t} lambda={eformat(wsamples[iw], 3, 2)}")
                hcipy.imshow_field(wf2.phase, cmap=sunlight)
                plt.colorbar()
                plt.show(block=True)


def add_atmos(wf, it):
    """
    creates a phase offset matrix for each wavelength at each time step,
    sampled from the atmosphere generated by hcipy

    HCIpy generates an atmosphere with given parameters. The returned field is in units of phase delay for each
    wavelength. prop_add_phase wants the phase delay to be in units of meters for each wavelength, so we convert to
    meters via the wavelength/np.pi

    :param wf: a single (2D) wfo.wf_collection[iw,ib] at one wavelength and object
    :param it: timestep# in obs_sequence. Comes from medis_main.gen_timeseries()
    :return: nothing returned, wfo is modified with proper.prop_add_phase
    """
    if tp.use_atmos is False:
        pass  # don't do anything. Putting this type of check here allows universal toggling on/off rather than
                # commenting/uncommenting in the proper perscription
    else:
        wavelength = wf.lamda  # the .lamda comes from proper, not from Wavefronts class

        # Check for Existing File
        atmos_map = get_filename(it, wavelength)
        # dprint(f"atmos map applied is {atmos_map}")
        if not os.path.exists(atmos_map):
            gen_atmos(plot=True)

        atm_map = fits.open(atmos_map)[1].data
        atm_map = unwrap_phase(atm_map)
        atm_map *= wavelength/(2*np.pi)  # converts atmosphere in units of phase delay (rad) into distance (m)
        proper.prop_add_phase(wf, atm_map)


def rotate_atmos(wf, it):
    time = it * ap.sample_time
    rotate_angle = tp.rot_rate * time
    wf.wfarr = proper.prop_shift_center(wf.wfarr)
    wf.wfarr = proper.prop_rotate(wf.wfarr, rotate_angle)
    wf.wfarr = proper.prop_shift_center(wf.wfarr)


def eformat(wvl, prec, exp_digits):
    """
    reformats wavelength into scientific notation in meters

    :param wvl: wavelength float
    :param prec: precision
    :param exp_digits: number of digits in the exponent
    :return:
    """
    s = "%.*e" % (prec, wvl)
    mantissa, exp = s.split('e')
    # add 1 to digits as 1 is taken by sign +/-
    return "%se%+0*d" % (mantissa, exp_digits + 1, int(exp))


def get_filename(it, lamda):
    """
    returns the atmosphere map names in the format location/atmos_t<time>_<model>_wvl<wavelength>
    example output:

    :param it: time index
    :param lamda: wavelength, comes from metadata in proper wavefront object (ie wfo.wf_collection.lamda)
    :return:
    """
    wave = eformat(lamda, 3, 2)

    return f'{iop.atmosdir}/atmos_t{sp.sample_time*it:.3f}_{atmp.model}_wvl{wave}.fits'

